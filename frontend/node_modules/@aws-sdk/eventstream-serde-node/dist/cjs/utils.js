"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readabletoIterable = void 0;
var tslib_1 = require("tslib");
/**
 * Convert object stream piped in into an async iterable. This
 * daptor should be deprecated when Node stream iterator is stable.
 * Caveat: this adaptor won't have backpressure to inwards stream
 *
 * Reference: https://nodejs.org/docs/latest-v11.x/api/stream.html#stream_readable_symbol_asynciterator
 */
function readabletoIterable(readStream) {
    return tslib_1.__asyncGenerator(this, arguments, function readabletoIterable_1() {
        var streamEnded, generationEnded, records, value;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    streamEnded = false;
                    generationEnded = false;
                    records = new Array();
                    readStream.on("error", function (err) {
                        if (!streamEnded) {
                            streamEnded = true;
                        }
                        if (err) {
                            throw err;
                        }
                    });
                    readStream.on("data", function (data) {
                        records.push(data);
                    });
                    readStream.on("end", function () {
                        streamEnded = true;
                    });
                    _a.label = 1;
                case 1:
                    if (!!generationEnded) return [3 /*break*/, 6];
                    return [4 /*yield*/, tslib_1.__await(new Promise(function (resolve) { return setTimeout(function () { return resolve(records.shift()); }, 0); }))];
                case 2:
                    value = _a.sent();
                    if (!value) return [3 /*break*/, 5];
                    return [4 /*yield*/, tslib_1.__await(value)];
                case 3: return [4 /*yield*/, _a.sent()];
                case 4:
                    _a.sent();
                    _a.label = 5;
                case 5:
                    generationEnded = streamEnded && records.length === 0;
                    return [3 /*break*/, 1];
                case 6: return [2 /*return*/];
            }
        });
    });
}
exports.readabletoIterable = readabletoIterable;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUVBOzs7Ozs7R0FNRztBQUVILFNBQXVCLGtCQUFrQixDQUFJLFVBQW9COzs7Ozs7b0JBQzNELFdBQVcsR0FBRyxLQUFLLENBQUM7b0JBQ3BCLGVBQWUsR0FBRyxLQUFLLENBQUM7b0JBQ3RCLE9BQU8sR0FBRyxJQUFJLEtBQUssRUFBSyxDQUFDO29CQUUvQixVQUFVLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxVQUFDLEdBQUc7d0JBQ3pCLElBQUksQ0FBQyxXQUFXLEVBQUU7NEJBQ2hCLFdBQVcsR0FBRyxJQUFJLENBQUM7eUJBQ3BCO3dCQUNELElBQUksR0FBRyxFQUFFOzRCQUNQLE1BQU0sR0FBRyxDQUFDO3lCQUNYO29CQUNILENBQUMsQ0FBQyxDQUFDO29CQUVILFVBQVUsQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLFVBQUMsSUFBSTt3QkFDekIsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDckIsQ0FBQyxDQUFDLENBQUM7b0JBRUgsVUFBVSxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUU7d0JBQ25CLFdBQVcsR0FBRyxJQUFJLENBQUM7b0JBQ3JCLENBQUMsQ0FBQyxDQUFDOzs7eUJBRUksQ0FBQyxlQUFlO29CQUNQLHFDQUFNLElBQUksT0FBTyxDQUFJLFVBQUMsT0FBTyxJQUFLLE9BQUEsVUFBVSxDQUFDLGNBQU0sT0FBQSxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQXhCLENBQXdCLEVBQUUsQ0FBQyxDQUFDLEVBQTdDLENBQTZDLENBQUMsR0FBQTs7b0JBQXhGLEtBQUssR0FBRyxTQUFnRjt5QkFDMUYsS0FBSyxFQUFMLHdCQUFLO3lEQUNELEtBQUs7d0JBQVgsZ0NBQVc7O29CQUFYLFNBQVcsQ0FBQzs7O29CQUVkLGVBQWUsR0FBRyxXQUFXLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7Ozs7OztDQUV6RDtBQTdCRCxnREE2QkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gXCJzdHJlYW1cIjtcblxuLyoqXG4gKiBDb252ZXJ0IG9iamVjdCBzdHJlYW0gcGlwZWQgaW4gaW50byBhbiBhc3luYyBpdGVyYWJsZS4gVGhpc1xuICogZGFwdG9yIHNob3VsZCBiZSBkZXByZWNhdGVkIHdoZW4gTm9kZSBzdHJlYW0gaXRlcmF0b3IgaXMgc3RhYmxlLlxuICogQ2F2ZWF0OiB0aGlzIGFkYXB0b3Igd29uJ3QgaGF2ZSBiYWNrcHJlc3N1cmUgdG8gaW53YXJkcyBzdHJlYW1cbiAqXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vbm9kZWpzLm9yZy9kb2NzL2xhdGVzdC12MTEueC9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3JlYWRhYmxlX3N5bWJvbF9hc3luY2l0ZXJhdG9yXG4gKi9cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uKiByZWFkYWJsZXRvSXRlcmFibGU8VD4ocmVhZFN0cmVhbTogUmVhZGFibGUpOiBBc3luY0l0ZXJhYmxlPFQ+IHtcbiAgbGV0IHN0cmVhbUVuZGVkID0gZmFsc2U7XG4gIGxldCBnZW5lcmF0aW9uRW5kZWQgPSBmYWxzZTtcbiAgY29uc3QgcmVjb3JkcyA9IG5ldyBBcnJheTxUPigpO1xuXG4gIHJlYWRTdHJlYW0ub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgaWYgKCFzdHJlYW1FbmRlZCkge1xuICAgICAgc3RyZWFtRW5kZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9KTtcblxuICByZWFkU3RyZWFtLm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgIHJlY29yZHMucHVzaChkYXRhKTtcbiAgfSk7XG5cbiAgcmVhZFN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgc3RyZWFtRW5kZWQgPSB0cnVlO1xuICB9KTtcblxuICB3aGlsZSAoIWdlbmVyYXRpb25FbmRlZCkge1xuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgbmV3IFByb21pc2U8VD4oKHJlc29sdmUpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShyZWNvcmRzLnNoaWZ0KCkpLCAwKSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gICAgZ2VuZXJhdGlvbkVuZGVkID0gc3RyZWFtRW5kZWQgJiYgcmVjb3Jkcy5sZW5ndGggPT09IDA7XG4gIH1cbn1cbiJdfQ==