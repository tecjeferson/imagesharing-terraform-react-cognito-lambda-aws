"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.clearCredentialCache = exports.getSigningKey = exports.createScope = void 0;
var tslib_1 = require("tslib");
var constants_1 = require("./constants");
var signingKeyCache = {};
var cacheQueue = [];
/**
 * Create a string describing the scope of credentials used to sign a request.
 *
 * @param shortDate The current calendar date in the form YYYYMMDD.
 * @param region    The AWS region in which the service resides.
 * @param service   The service to which the signed request is being sent.
 */
function createScope(shortDate, region, service) {
    return shortDate + "/" + region + "/" + service + "/" + constants_1.KEY_TYPE_IDENTIFIER;
}
exports.createScope = createScope;
/**
 * Derive a signing key from its composite parts
 *
 * @param sha256Constructor A constructor function that can instantiate SHA-256
 *                          hash objects.
 * @param credentials       The credentials with which the request will be
 *                          signed.
 * @param shortDate         The current calendar date in the form YYYYMMDD.
 * @param region            The AWS region in which the service resides.
 * @param service           The service to which the signed request is being
 *                          sent.
 */
function getSigningKey(sha256Constructor, credentials, shortDate, region, service) {
    var cacheKey = shortDate + ":" + region + ":" + service + ":" + (credentials.accessKeyId + ":" + credentials.sessionToken);
    if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > constants_1.MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
    }
    return (signingKeyCache[cacheKey] = new Promise(function (resolve, reject) {
        var e_1, _a;
        var keyPromise = Promise.resolve("AWS4" + credentials.secretAccessKey);
        var _loop_1 = function (signable) {
            keyPromise = keyPromise.then(function (intermediateKey) { return hmac(sha256Constructor, intermediateKey, signable); });
            keyPromise.catch(function () { });
        };
        try {
            for (var _b = tslib_1.__values([shortDate, region, service, constants_1.KEY_TYPE_IDENTIFIER]), _c = _b.next(); !_c.done; _c = _b.next()) {
                var signable = _c.value;
                _loop_1(signable);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        keyPromise.then(resolve, function (reason) {
            delete signingKeyCache[cacheKey];
            reject(reason);
        });
    }));
}
exports.getSigningKey = getSigningKey;
/**
 * @internal
 */
function clearCredentialCache() {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach(function (cacheKey) {
        delete signingKeyCache[cacheKey];
    });
}
exports.clearCredentialCache = clearCredentialCache;
function hmac(ctor, secret, data) {
    var hash = new ctor(secret);
    hash.update(data);
    return hash.digest();
}
//# sourceMappingURL=credentialDerivation.js.map