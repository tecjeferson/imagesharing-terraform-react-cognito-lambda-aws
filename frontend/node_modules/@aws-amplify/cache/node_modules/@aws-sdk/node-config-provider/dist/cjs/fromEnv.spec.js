"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var property_provider_1 = require("@aws-sdk/property-provider");
var fromEnv_1 = require("./fromEnv");
describe("fromEnv", function () {
    describe("with env var getter", function () {
        var envVarName = "ENV_VAR_NAME";
        var envVarGetter = function (env) { return env[envVarName]; };
        var envVarValue = process.env[envVarName];
        var mockEnvVarValue = "mockEnvVarValue";
        var getProviderError = function (getter) {
            return new property_provider_1.ProviderError("Cannot load config from environment variables with getter: " + getter);
        };
        beforeEach(function () {
            delete process.env[envVarName];
        });
        afterAll(function () {
            process.env[envVarName] = envVarValue;
        });
        it("returns string value in '" + envVarName + "' env var when set", function () {
            process.env[envVarName] = mockEnvVarValue;
            return expect(fromEnv_1.fromEnv(envVarGetter)()).resolves.toBe(mockEnvVarValue);
        });
        it("return complex value from the getter", function () {
            var value = { Foo: "bar" };
            var getter = jest.fn().mockReturnValue(value);
            // Validate the generic type works
            return expect(fromEnv_1.fromEnv(getter)()).resolves.toEqual(value);
        });
        it("throws when '" + envVarName + "' env var is not set", function () {
            expect.assertions(1);
            return expect(fromEnv_1.fromEnv(envVarGetter)()).rejects.toMatchObject(getProviderError(envVarGetter));
        });
        it("throws when the getter function throws", function () {
            var exception = new Error("Exception when getting the config");
            var getter = jest.fn().mockRejectedValue(exception);
            return expect(fromEnv_1.fromEnv(getter)()).rejects.toEqual(exception);
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJvbUVudi5zcGVjLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Zyb21FbnYuc3BlYy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLGdFQUEyRDtBQUUzRCxxQ0FBbUQ7QUFFbkQsUUFBUSxDQUFDLFNBQVMsRUFBRTtJQUNsQixRQUFRLENBQUMscUJBQXFCLEVBQUU7UUFDOUIsSUFBTSxVQUFVLEdBQUcsY0FBYyxDQUFDO1FBQ2xDLElBQU0sWUFBWSxHQUEwQixVQUFDLEdBQXNCLElBQUssT0FBQSxHQUFHLENBQUMsVUFBVSxDQUFFLEVBQWhCLENBQWdCLENBQUM7UUFDekYsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM1QyxJQUFNLGVBQWUsR0FBRyxpQkFBaUIsQ0FBQztRQUUxQyxJQUFNLGdCQUFnQixHQUFHLFVBQUMsTUFBNkI7WUFDckQsT0FBQSxJQUFJLGlDQUFhLENBQUMsZ0VBQThELE1BQVEsQ0FBQztRQUF6RixDQUF5RixDQUFDO1FBRTVGLFVBQVUsQ0FBQztZQUNULE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNqQyxDQUFDLENBQUMsQ0FBQztRQUVILFFBQVEsQ0FBQztZQUNQLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsV0FBVyxDQUFDO1FBQ3hDLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLDhCQUE0QixVQUFVLHVCQUFvQixFQUFFO1lBQzdELE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsZUFBZSxDQUFDO1lBQzFDLE9BQU8sTUFBTSxDQUFDLGlCQUFPLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDeEUsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsc0NBQXNDLEVBQUU7WUFFekMsSUFBTSxLQUFLLEdBQVUsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLENBQUM7WUFDcEMsSUFBTSxNQUFNLEdBQXdCLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDckUsa0NBQWtDO1lBQ2xDLE9BQU8sTUFBTSxDQUFDLGlCQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0QsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsa0JBQWdCLFVBQVUseUJBQXNCLEVBQUU7WUFDbkQsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyQixPQUFPLE1BQU0sQ0FBQyxpQkFBTyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUM7UUFDL0YsQ0FBQyxDQUFDLENBQUM7UUFFSCxFQUFFLENBQUMsd0NBQXdDLEVBQUU7WUFDM0MsSUFBTSxTQUFTLEdBQUcsSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztZQUNqRSxJQUFNLE1BQU0sR0FBc0IsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3pFLE9BQU8sTUFBTSxDQUFDLGlCQUFPLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDOUQsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJvdmlkZXJFcnJvciB9IGZyb20gXCJAYXdzLXNkay9wcm9wZXJ0eS1wcm92aWRlclwiO1xuXG5pbXBvcnQgeyBmcm9tRW52LCBHZXR0ZXJGcm9tRW52IH0gZnJvbSBcIi4vZnJvbUVudlwiO1xuXG5kZXNjcmliZShcImZyb21FbnZcIiwgKCkgPT4ge1xuICBkZXNjcmliZShcIndpdGggZW52IHZhciBnZXR0ZXJcIiwgKCkgPT4ge1xuICAgIGNvbnN0IGVudlZhck5hbWUgPSBcIkVOVl9WQVJfTkFNRVwiO1xuICAgIGNvbnN0IGVudlZhckdldHRlcjogR2V0dGVyRnJvbUVudjxzdHJpbmc+ID0gKGVudjogTm9kZUpTLlByb2Nlc3NFbnYpID0+IGVudltlbnZWYXJOYW1lXSE7XG4gICAgY29uc3QgZW52VmFyVmFsdWUgPSBwcm9jZXNzLmVudltlbnZWYXJOYW1lXTtcbiAgICBjb25zdCBtb2NrRW52VmFyVmFsdWUgPSBcIm1vY2tFbnZWYXJWYWx1ZVwiO1xuXG4gICAgY29uc3QgZ2V0UHJvdmlkZXJFcnJvciA9IChnZXR0ZXI6IEdldHRlckZyb21FbnY8c3RyaW5nPikgPT5cbiAgICAgIG5ldyBQcm92aWRlckVycm9yKGBDYW5ub3QgbG9hZCBjb25maWcgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgd2l0aCBnZXR0ZXI6ICR7Z2V0dGVyfWApO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBkZWxldGUgcHJvY2Vzcy5lbnZbZW52VmFyTmFtZV07XG4gICAgfSk7XG5cbiAgICBhZnRlckFsbCgoKSA9PiB7XG4gICAgICBwcm9jZXNzLmVudltlbnZWYXJOYW1lXSA9IGVudlZhclZhbHVlO1xuICAgIH0pO1xuXG4gICAgaXQoYHJldHVybnMgc3RyaW5nIHZhbHVlIGluICcke2VudlZhck5hbWV9JyBlbnYgdmFyIHdoZW4gc2V0YCwgKCkgPT4ge1xuICAgICAgcHJvY2Vzcy5lbnZbZW52VmFyTmFtZV0gPSBtb2NrRW52VmFyVmFsdWU7XG4gICAgICByZXR1cm4gZXhwZWN0KGZyb21FbnYoZW52VmFyR2V0dGVyKSgpKS5yZXNvbHZlcy50b0JlKG1vY2tFbnZWYXJWYWx1ZSk7XG4gICAgfSk7XG5cbiAgICBpdChcInJldHVybiBjb21wbGV4IHZhbHVlIGZyb20gdGhlIGdldHRlclwiLCAoKSA9PiB7XG4gICAgICB0eXBlIFZhbHVlID0geyBGb286IHN0cmluZyB9O1xuICAgICAgY29uc3QgdmFsdWU6IFZhbHVlID0geyBGb286IFwiYmFyXCIgfTtcbiAgICAgIGNvbnN0IGdldHRlcjogKGVudjogYW55KSA9PiBWYWx1ZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUodmFsdWUpO1xuICAgICAgLy8gVmFsaWRhdGUgdGhlIGdlbmVyaWMgdHlwZSB3b3Jrc1xuICAgICAgcmV0dXJuIGV4cGVjdChmcm9tRW52KGdldHRlcikoKSkucmVzb2x2ZXMudG9FcXVhbCh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBpdChgdGhyb3dzIHdoZW4gJyR7ZW52VmFyTmFtZX0nIGVudiB2YXIgaXMgbm90IHNldGAsICgpID0+IHtcbiAgICAgIGV4cGVjdC5hc3NlcnRpb25zKDEpO1xuICAgICAgcmV0dXJuIGV4cGVjdChmcm9tRW52KGVudlZhckdldHRlcikoKSkucmVqZWN0cy50b01hdGNoT2JqZWN0KGdldFByb3ZpZGVyRXJyb3IoZW52VmFyR2V0dGVyKSk7XG4gICAgfSk7XG5cbiAgICBpdChcInRocm93cyB3aGVuIHRoZSBnZXR0ZXIgZnVuY3Rpb24gdGhyb3dzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGV4Y2VwdGlvbiA9IG5ldyBFcnJvcihcIkV4Y2VwdGlvbiB3aGVuIGdldHRpbmcgdGhlIGNvbmZpZ1wiKTtcbiAgICAgIGNvbnN0IGdldHRlcjogKGVudjogYW55KSA9PiBhbnkgPSBqZXN0LmZuKCkubW9ja1JlamVjdGVkVmFsdWUoZXhjZXB0aW9uKTtcbiAgICAgIHJldHVybiBleHBlY3QoZnJvbUVudihnZXR0ZXIpKCkpLnJlamVjdHMudG9FcXVhbChleGNlcHRpb24pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19